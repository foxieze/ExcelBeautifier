{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/taskpane/taskpane.js","webpack:///./node_modules/excel-formula/index.js","webpack:///./node_modules/excel-formula/src/core.js","webpack:///./node_modules/excel-formula/src/ExcelFormulaUtilities.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","formula","require","updateFormulaArea","event","Excel","run","context","range","workbook","getSelectedRange","load","sync","then","document","getElementById","innerHTML","formatFormulaHTML","formulas","toString","error","console","log","Office","onReady","info","host","HostType","style","display","onSelectionChanged","add","xl","excelFormulaUtilities","getTokens","f","items","formatFormula","opts","toJavaScript","formula2JavaScript","toCSharp","formula2CSharp","toPython","formula2Python","this","window","root","core","string","formatStr","inStr","formattedStr","argIndex","arguments","length","replaceIndex","replaceRegex","RegExp","replace","trim","isFunction","obj","isArray","isWindow","isPlainObject","nodeType","constructor","lastKey","undefined","extend","options","src","copy","copyIsArray","clone","target","deep","types","TOK_TYPE_NOOP","TOK_TYPE_OPERAND","TOK_TYPE_FUNCTION","TOK_TYPE_SUBEXPR","TOK_TYPE_ARGUMENT","TOK_TYPE_OP_PRE","TOK_TYPE_OP_IN","TOK_TYPE_OP_POST","TOK_TYPE_WSPACE","TOK_TYPE_UNKNOWN","TOK_SUBTYPE_START","TOK_SUBTYPE_STOP","TOK_SUBTYPE_TEXT","TOK_SUBTYPE_NUMBER","TOK_SUBTYPE_LOGICAL","TOK_SUBTYPE_ERROR","TOK_SUBTYPE_RANGE","TOK_SUBTYPE_MATH","TOK_SUBTYPE_CONCAT","TOK_SUBTYPE_INTERSECT","TOK_SUBTYPE_UNION","F_token","type","subtype","F_tokens","token","addRef","push","index","reset","BOF","EOF","moveNext","current","next","previous","F_tokenStack","pop","tokens","tokenStack","offset","currentChar","substr","doubleChar","nextChar","inString","inPath","inRange","inError","regexSN","indexOf","match","isEu","tokens2","doAddToken","isNaN","parseFloat","parseFormula","inputID","outputID","indentCount","indent","formulaControl","tokensHtml","split","join","select","focus","breakOutRanges","rangeStr","delimStr","test","startRow","parseInt","startCol","startColDec","fromBase26","endRow","endCol","endColDec","totalRows","totalCols","curCol","curRow","curCell","retStr","toBase26","Math","abs","remainder","converted","iteration","String","fromCharCode","charCodeAt","floor","number","dec","toUpperCase","pow","applyTokenTemplate","lineBreak","override","indt","lastToken","replaceTokenTmpl","tokenString","returnVal","useTemplate","tmplFunctionStartArray","tmplFunctionStartArrayRow","tmplFunctionStart","tmplFunctionStop","tmplOperandError","tmplOperandRange","tmplOperandLogical","tmplOperandNumber","tmplOperandText","tmplArgument","tmplOperandOperatorInfix","tmplLogical","tmplSubexpressionStart","tmplSubexpressionStop","defaultOptions","tmplFunctionStopArrayRow","tmplFunctionStopArray","tmplIndentTab","tmplIndentSpace","autoLineBreak","newLine","customTokenRender","prefix","postfix","outputFormula","autoBreakArray","isNewLine","testAutoBreak","nextToken","matchEndNewLine","autoBreak","tokenStr","linbreak","outstr","functionStack","directConversionMap","currentFunctionOnStack","argumentNumber","toLowerCase","outStr"],"mappings":"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","file":"taskpane.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 307);\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n * See LICENSE in the project root for license information.\n */\n\n/* global console, document, Excel, Office */\n\nconst formula = require(\"excel-formula\")\n\nOffice.onReady(info => {\n    if (info.host === Office.HostType.Excel) {\n        document.getElementById(\"sideload-msg\").style.display = \"none\";\n        document.getElementById(\"app-body\").style.display = \"block\";\n        updateFormulaArea(null);\n        Excel.run(function(context) {\n            var workbook = context.workbook;\n            workbook.onSelectionChanged.add(updateFormulaArea);\n\n            return context.sync()\n                .then(function() {\n                    console.log(\"Event handler successfully registered for onChanged event in the worksheet.\");\n                });\n        }).catch(error);\n    }\n});\n\nfunction updateFormulaArea(event) {\n    return Excel.run(function(context) {\n        const range = context.workbook.getSelectedRange();\n            // range.format.fill.color = \"yellow\";\n            range.load(\"formulas\");\n            return context.sync().then(function() {\n                try {\n                    document.getElementById(\"area\").innerHTML = formula.formatFormulaHTML(range.formulas.toString());\n                } catch (error) {\n                    console.log(error);\n                }\n            });\n    })\n} \n\n","// Generated by CoffeeScript 1.3.3\r\n(function() {\r\n  var xl;\r\n\r\n  require('./src/core');\r\n\r\n  require('./src/ExcelFormulaUtilities');\r\n\r\n  xl = excelFormulaUtilities;\r\n\r\n  module.exports = {\r\n    getTokens: function(f) {\r\n      return xl.getTokens(f).items;\r\n    },\r\n    formatFormula: function(f, opts) {\r\n      return xl.formatFormula(f, opts);\r\n    },\r\n    formatFormulaHTML: xl.formatFormulaHTML,\r\n    toJavaScript: xl.formula2JavaScript,\r\n    toCSharp: xl.formula2CSharp,\r\n    toPython: xl.formula2Python\r\n  };\r\n\r\n}).call(this);\r\n","/*\r\n * excelFormulaUtilitiesJS\r\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\r\n *\r\n * Copyright 2011, Josh Bennett\r\n * licensed under the MIT license.\r\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\r\n *\r\n * Some functionality based off of the jquery core lib\r\n * Copyright 2011, John Resig\r\n * Dual licensed under the MIT or GPL Version 2 licenses.\r\n * http://jquery.org/license\r\n *\r\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\r\n */\r\n \r\n(function () {\r\n\r\n    if (typeof window === 'undefined') {\r\n      window = root;\r\n    }\r\n    var excelFormulaUtilities = window.excelFormulaUtilities = window.excelFormulaUtilities || {};\r\n    var core = window.excelFormulaUtilities.core = {};\r\n\twindow.excelFormulaUtilities.string = window.excelFormulaUtilities.string || {};\r\n\t\r\n\t/**\r\n\t* Simple/quick string formater. This will take an input string and apply n number of arguments to it.\r\n\t*\r\n\t* <b>example:</b><br />\r\n\t* <code>\r\n\t* <pre>\r\n\t*\tvar foo = excelFormulaUtilities.core.formatStr(\"{0}\", \"foo\"); // foo will be set to \"foo\"\r\n\t*\tvar fooBar = excelFormulaUtilities.core.formatStr(\"{0} {1}\", \"foo\", \"bar\"); // fooBar will be set to \"fooBar\"\r\n\t*\tvar error = excelFormulaUtilities.core.formatStr(\"{1}\", \"error\"); // will throw an index out of range error since only 1 extra argument was passed, which would be index 0.\r\n\t* </pre>\r\n\t* </code>\r\n\t*\r\n    * @memberOf window.excelFormulaUtilities.core\r\n\t* @function\r\n    * @param {String} inStr \r\n    **/\r\n\tvar formatStr = window.excelFormulaUtilities.string.formatStr = function(inStr) {\r\n\t\t\tvar formattedStr = inStr;\r\n\t\t\tvar argIndex = 1;\r\n\t\t\tfor (; argIndex < arguments.length; argIndex++) {\r\n\t\t\t\tvar replaceIndex = (argIndex - 1);\r\n\t\t\t\tvar replaceRegex = new RegExp(\"\\\\{{1}\" + replaceIndex.toString() + \"{1}\\\\}{1}\", \"g\");\r\n\t\t\t\tformattedStr = formattedStr.replace(replaceRegex, arguments[argIndex]);\r\n\t\t\t}\r\n\t\t\treturn formattedStr;\r\n\t\t};\r\n    \r\n    var trim = window.excelFormulaUtilities.string.trim = function(inStr){\r\n\t\t\treturn inStr.replace(/^\\s|\\s$/, \"\");\r\n\t\t};\r\n\t\r\n\tvar trimHTML = window.excelFormulaUtilities.string.trim = function(inStr){\r\n\t\t\treturn inStr.replace(/^(?:\\s|&nbsp;|<\\s*br\\s*\\/*\\s*>)*|(?:\\s|&nbsp;|<\\s*br\\s*\\/*\\s*>)*$/, \"\");\r\n\t\t};\r\n\r\n\t//Quick and dirty type checks\r\n\t/**\r\n\t* @param {object} obj\r\n\t* @returns {boolean}\r\n\t* @memberOf window.excelFormulaUtilities.core\r\n\t*/\r\n\tvar isFunction = core.isFunction = function (obj) {\r\n\t\treturn (typeof obj) === \"function\";\r\n\t};\r\n\r\n\t/**\r\n\t* @param {object} obj\r\n\t* @returns {boolean}\r\n\t* @memberOf window.excelFormulaUtilities.core\r\n\t*/\r\n\tvar isArray = core.isArray = function (obj) {\r\n\t\treturn (typeof obj) === \"object\" && obj.length;\r\n\t};\r\n\r\n\t/**\r\n\t* @param {object} obj\r\n\t* @returns {boolean}\r\n\t* @memberOf window.excelFormulaUtilities.core\r\n\t*/\r\n\tvar isWindow = core.isWindow = function () {\r\n\t\treturn obj && typeof obj === \"object\" && \"setInterval\" in obj;\r\n\t}; /*----The functionality below has based off of the jQuery core library----*/\r\n\r\n\t/**\r\n\t* Check if the object is a plain object or not. This has been pulled from the jQuery core and modified slightly.\r\n\t* @param {object} obj\r\n\t* @returns {boolean} returns weather the object is a plain object or not.\r\n\t* @memberOf window.excelFormulaUtilities.core\r\n\t*/\r\n\tvar isPlainObject = core.isPlainObject = function (obj) {\r\n\t\t// Must be an Object.\r\n\t\t// Because of IE, we also have to check the presence of the constructor property.\r\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\r\n\t\tif (!obj || typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Not own constructor property must be Object\r\n\t\tif (obj.constructor && !hasOwnProperty.call(obj, \"constructor\") && !hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Own properties are enumerated firstly, so to speed up,\r\n\t\t// if last one is own, then all properties are own.\r\n\t\tvar lastKey;\r\n\t\tfor (key in obj) { lastKey = key; }\r\n\t\treturn lastKey === undefined || hasOwnProperty.call(obj, lastKey);\r\n\t};\r\n\r\n\t/**\r\n\t* This has been pulled from the jQuery core and modified slightly. see http://api.jquery.com/jQuery.extend/\r\n\t* @param {object} target\r\n\t* @param {object} object add one or more object to extend the target.\r\n\t* @returns {object} returns the extended object.\r\n\t* @memberOf window.excelFormulaUtilities.core\r\n\t*/\r\n\tvar extend = core.extend = function () {\r\n\t\tvar options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\t\t// Handle a deep copy situation\r\n\t\tif (typeof target === \"boolean\") {\r\n\t\t\tdeep = target;\r\n\t\t\ttarget = arguments[1] || {};\r\n\t\t\t// skip the boolean and the target\r\n\t\t\ti = 2;\r\n\t\t}\r\n\t\t// Handle case when target is a string or something (possible in deep copy)\r\n\t\tif (typeof target !== \"object\" && !isFunction(target)) {\r\n\t\t\ttarget = {};\r\n\t\t}\r\n\t\t// extend jQuery itself if only one argument is passed\r\n\t\tif (length === i) {\r\n\t\t\ttarget = this;\r\n\t\t\t--i;\r\n\t\t}\r\n\t\tfor (; i < length; i++) {\r\n\t\t\t// Only deal with non-null/undefined values\r\n\t\t\tif ((options = arguments[i]) != null) {\r\n\t\t\t\t// Extend the base object\r\n\t\t\t\tfor (name in options) {\r\n\t\t\t\t\tsrc = target[name];\r\n\t\t\t\t\tcopy = options[name];\r\n\t\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\t\tif (target === copy) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\r\n\t\t\t\t\t\tif (copyIsArray) {\r\n\t\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\t\ttarget[name] = core.extend(deep, clone, copy);\r\n\t\t\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t\t} else if (copy !== undefined) {\r\n\t\t\t\t\t\ttarget[name] = copy;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Return the modified object\r\n\t\treturn target;\r\n\t}; /*----end of jquery functionality----*/\r\n\r\n\t\r\n}());\r\n","/*\n * excelFormulaUtilitiesJS\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/\n *\n * Copyright 2011, Josh Bennett\n * licensed under the MIT license.\n * https://github.com/joshatjben/excelFormulaUtilitiesJS/blob/master/LICENSE.txt\n *\n * Some functionality based off of the jquery core lib\n * Copyright 2011, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Based on Ewbi's Go Calc Prototype Excel Formula Parser. [http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html]\n */\n(function (root) {\n    var excelFormulaUtilities = root.excelFormulaUtilities = root.excelFormulaUtilities || {},\n    core = root.excelFormulaUtilities.core,\n        formatStr = root.excelFormulaUtilities.string.formatStr,\n        trim = root.excelFormulaUtilities.string.trim,\n\n        types = {},\n        TOK_TYPE_NOOP = types.TOK_TYPE_NOOP = \"noop\",\n        TOK_TYPE_OPERAND = types.TOK_TYPE_OPERAND = \"operand\",\n        TOK_TYPE_FUNCTION = types.TOK_TYPE_FUNCTION = \"function\",\n        TOK_TYPE_SUBEXPR = types.TOK_TYPE_SUBEXPR = \"subexpression\",\n        TOK_TYPE_ARGUMENT = types.TOK_TYPE_ARGUMENT = \"argument\",\n        TOK_TYPE_OP_PRE = types.TOK_TYPE_OP_PRE = \"operator-prefix\",\n        TOK_TYPE_OP_IN = types.TOK_TYPE_OP_IN = \"operator-infix\",\n        TOK_TYPE_OP_POST = types.TOK_TYPE_OP_POST = \"operator-postfix\",\n        TOK_TYPE_WSPACE = types.TOK_TYPE_WSPACE = \"white-space\",\n        TOK_TYPE_UNKNOWN = types.TOK_TYPE_UNKNOWN = \"unknown\",\n\n        TOK_SUBTYPE_START = types.TOK_SUBTYPE_START = \"start\",\n        TOK_SUBTYPE_STOP = types.TOK_SUBTYPE_STOP = \"stop\",\n\n        TOK_SUBTYPE_TEXT = types.TOK_SUBTYPE_TEXT = \"text\",\n        TOK_SUBTYPE_NUMBER = types.TOK_SUBTYPE_NUMBER = \"number\",\n        TOK_SUBTYPE_LOGICAL = types.TOK_SUBTYPE_LOGICAL = \"logical\",\n        TOK_SUBTYPE_ERROR = types.TOK_SUBTYPE_ERROR = \"error\",\n        TOK_SUBTYPE_RANGE = types.TOK_SUBTYPE_RANGE = \"range\",\n\n        TOK_SUBTYPE_MATH = types.TOK_SUBTYPE_MATH = \"math\",\n        TOK_SUBTYPE_CONCAT = types.TOK_SUBTYPE_CONCAT = \"concatenate\",\n        TOK_SUBTYPE_INTERSECT = types.TOK_SUBTYPE_INTERSECT = \"intersect\",\n        TOK_SUBTYPE_UNION = types.TOK_SUBTYPE_UNION = \"union\";\n\n    root.excelFormulaUtilities.isEu = typeof root.excelFormulaUtilities.isEu === 'boolean' ? root.excelFormulaUtilities.isEu : false;\n\n\n    /**\n     * @class\n     */\n\n    function F_token(value, type, subtype) {\n        this.value = value;\n        this.type = type;\n        this.subtype = subtype;\n    }\n\n    /**\n     * @class\n     */\n\n    function F_tokens() {\n\n        this.items = [];\n\n        this.add = function (value, type, subtype) {\n            if (!subtype) {\n                subtype = \"\";\n            }\n            var token = new F_token(value, type, subtype);\n            this.addRef(token);\n            return token;\n        };\n        this.addRef = function (token) {\n            this.items.push(token);\n        };\n\n        this.index = -1;\n        this.reset = function () {\n            this.index = -1;\n        };\n        this.BOF = function () {\n            return (this.index <= 0);\n        };\n        this.EOF = function () {\n            return (this.index >= (this.items.length - 1));\n        };\n        this.moveNext = function () {\n            if (this.EOF()) {\n                return false;\n            }\n            this.index += 1;\n            return true;\n        };\n        this.current = function () {\n            if (this.index === -1) {\n                return null;\n            }\n            return (this.items[this.index]);\n        };\n        this.next = function () {\n            if (this.EOF()) {\n                return null;\n            }\n            return (this.items[this.index + 1]);\n        };\n        this.previous = function () {\n            if (this.index < 1) {\n                return null;\n            }\n            return (this.items[this.index - 1]);\n        };\n\n    }\n\n    function F_tokenStack() {\n\n        this.items = [];\n\n        this.push = function (token) {\n            this.items.push(token);\n        };\n        this.pop = function (name) {\n            var token = this.items.pop();\n            return (new F_token(name || \"\", token.type, TOK_SUBTYPE_STOP));\n        };\n\n        this.token = function () {\n            return ((this.items.length > 0) ? this.items[this.items.length - 1] : null);\n        };\n        this.value = function () {\n            return ((this.token()) ? this.token().value.toString() : \"\");\n        };\n        this.type = function () {\n            return ((this.token()) ? this.token().type.toString() : \"\");\n        };\n        this.subtype = function () {\n            return ((this.token()) ? this.token().subtype.toString() : \"\");\n        };\n\n    }\n\n    function getTokens(formula) {\n\n        var tokens = new F_tokens(),\n            tokenStack = new F_tokenStack(),\n\n            offset = 0,\n\n            currentChar = function () {\n                return formula.substr(offset, 1);\n            },\n            doubleChar = function () {\n                return formula.substr(offset, 2);\n            },\n            nextChar = function () {\n                return formula.substr(offset + 1, 1);\n            },\n            EOF = function () {\n                return (offset >= formula.length);\n            },\n\n            token = \"\",\n\n            inString = false,\n            inPath = false,\n            inRange = false,\n            inError = false,\n            regexSN = /^[1-9]{1}(\\.[0-9]+)?E{1}$/;\n\n        while (formula.length > 0) {\n            if (formula.substr(0, 1) === \" \") {\n                formula = formula.substr(1);\n            } else {\n                if (formula.substr(0, 1) === \"=\") {\n                    formula = formula.substr(1);\n                }\n                break;\n            }\n        }\n\n\n\n        while (!EOF()) {\n\n            // state-dependent character evaluation (order is important)\n            // double-quoted strings\n            // embeds are doubled\n            // end marks token\n            if (inString) {\n                if (currentChar() === \"\\\"\") {\n                    if (nextChar() === \"\\\"\") {\n                        token += \"\\\"\";\n                        offset += 1;\n                    } else {\n                        inString = false;\n                        tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_TEXT);\n                        token = \"\";\n                    }\n                } else {\n                    token += currentChar();\n                }\n                offset += 1;\n                continue;\n            }\n\n            // single-quoted strings (links)\n            // embeds are double\n            // end does not mark a token\n            if (inPath) {\n                if (currentChar() === \"'\") {\n\n                    if (nextChar() === \"'\") {\n                        token += \"'\";\n                        offset += 1;\n                    } else {\n                        inPath = false;\n                        token += \"'\";\n                    }\n                } else {\n                    token += currentChar();\n                }\n\n                offset += 1;\n                continue;\n            }\n\n            // bracked strings (range offset or linked workbook name)\n            // no embeds (changed to \"()\" by Excel)\n            // end does not mark a token\n            if (inRange) {\n                if (currentChar() === \"]\") {\n                    inRange = false;\n                }\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // error values\n            // end marks a token, determined from absolute list of values\n            if (inError) {\n                token += currentChar();\n                offset += 1;\n                if ((\",#NULL!,#DIV/0!,#VALUE!,#REF!,#NAME?,#NUM!,#N/A,\").indexOf(\",\" + token + \",\") !== -1) {\n                    inError = false;\n                    tokens.add(token, TOK_TYPE_OPERAND, TOK_SUBTYPE_ERROR);\n                    token = \"\";\n                }\n                continue;\n            }\n\n            // scientific notation check\n            if ((\"+-\").indexOf(currentChar()) !== -1) {\n                if (token.length > 1) {\n                    if (token.match(regexSN)) {\n                        token += currentChar();\n                        offset += 1;\n                        continue;\n                    }\n                }\n            }\n\n            // independent character evaulation (order not important)\n            // establish state-dependent character evaluations\n            if (currentChar() === \"\\\"\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inString = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"'\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                token = \"'\"\n                inPath = true;\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"[\") {\n                inRange = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \"#\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                inError = true;\n                token += currentChar();\n                offset += 1;\n                continue;\n            }\n\n            // mark start and end of arrays and array rows\n            if (currentChar() === \"{\") {\n                if (token.length > 0) {\n                    // not expected\n                    tokens.add(token, TOK_TYPE_UNKNOWN);\n                    token = \"\";\n                }\n                tokenStack.push(tokens.add(\"ARRAY\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                offset += 1;\n                continue;\n            }\n\n            if (currentChar() === \";\" ) {\n                if(root.excelFormulaUtilities.isEu){\n                    // If is EU then handle ; as list seperators\n                    if (token.length > 0) {\n                        tokens.add(token, TOK_TYPE_OPERAND);\n                        token = \"\";\n                    }\n                    if (tokenStack.type() !== TOK_TYPE_FUNCTION) {\n                        tokens.add(currentChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_UNION);\n                    } else {\n                        tokens.add(currentChar(), TOK_TYPE_ARGUMENT);\n                    }\n                    offset += 1;\n                    continue;\n                } else {\n                    // Else if not Eu handle ; as array row seperator\n                    if (token.length > 0) {\n                        tokens.add(token, TOK_TYPE_OPERAND);\n                        token = \"\";\n                    }\n                    tokens.addRef(tokenStack.pop());\n                    tokens.add(\",\", TOK_TYPE_ARGUMENT);\n                    tokenStack.push(tokens.add(\"ARRAYROW\", TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                    offset += 1;\n                    continue;\n                }\n            }\n\n            if (currentChar() === \"}\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop(\"ARRAYROWSTOP\"));\n                tokens.addRef(tokenStack.pop(\"ARRAYSTOP\"));\n                offset += 1;\n                continue;\n            }\n\n            // trim white-space\n            if (currentChar() === \" \") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(\"\", TOK_TYPE_WSPACE);\n                offset += 1;\n                while ((currentChar() === \" \") && (!EOF())) {\n                    offset += 1;\n                }\n                continue;\n            }\n\n            // multi-character comparators\n            if ((\",>=,<=,<>,\").indexOf(\",\" + doubleChar() + \",\") !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(doubleChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_LOGICAL);\n                offset += 2;\n                continue;\n            }\n\n            // standard infix operators\n            if ((\"+-*/^&=><\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_IN);\n                offset += 1;\n                continue;\n            }\n\n            // standard postfix operators\n            if ((\"%\").indexOf(currentChar()) !== -1) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.add(currentChar(), TOK_TYPE_OP_POST);\n                offset += 1;\n                continue;\n            }\n\n            // start subexpression or function\n            if (currentChar() === \"(\") {\n                if (token.length > 0) {\n                    tokenStack.push(tokens.add(token, TOK_TYPE_FUNCTION, TOK_SUBTYPE_START));\n                    token = \"\";\n                } else {\n                    tokenStack.push(tokens.add(\"\", TOK_TYPE_SUBEXPR, TOK_SUBTYPE_START));\n                }\n                offset += 1;\n                continue;\n            }\n\n            // function, subexpression, array parameters\n            if (currentChar() === \",\" && !root.excelFormulaUtilities.isEu) {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                if (tokenStack.type() !== TOK_TYPE_FUNCTION) {\n                    tokens.add(currentChar(), TOK_TYPE_OP_IN, TOK_SUBTYPE_UNION);\n                } else {\n                    tokens.add(currentChar(), TOK_TYPE_ARGUMENT);\n                }\n                offset += 1;\n                continue;\n            }\n\n            // stop subexpression\n            if (currentChar() === \")\") {\n                if (token.length > 0) {\n                    tokens.add(token, TOK_TYPE_OPERAND);\n                    token = \"\";\n                }\n                tokens.addRef(tokenStack.pop());\n                offset += 1;\n                continue;\n            }\n\n            // token accumulation\n            token += currentChar();\n            offset += 1;\n\n        }\n\n        // dump remaining accumulation\n        if (token.length > 0 || inString || inPath || inRange || inError) {\n          if (inString || inPath || inRange || inError) {\n            if (inString) {\n              token = \"\\\"\" + token;\n            } else if (inPath) {\n              token = \"'\" + token;\n            } else if (inRange) {\n              token = \"[\" + token;\n            } else if (inError) {\n              token = \"#\" + token;\n            }\n\n            tokens.add(token, TOK_TYPE_UNKNOWN);\n          } else {\n            tokens.add(token, TOK_TYPE_OPERAND);\n          }\n        }\n\n        // move all tokens to a new collection, excluding all unnecessary white-space tokens\n        var tokens2 = new F_tokens();\n\n        while (tokens.moveNext()) {\n\n            token = tokens.current();\n\n            if (token.type.toString() === TOK_TYPE_WSPACE) {\n                var doAddToken = (tokens.BOF()) || (tokens.EOF());\n                //if ((tokens.BOF()) || (tokens.EOF())) {}\n                doAddToken = doAddToken && (((tokens.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens.previous().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //       ((tokens.previous().type === TOK_TYPE_FUNCTION) && (tokens.previous().subtype == TOK_SUBTYPE_STOP))\n                //    || ((tokens.previous().type == TOK_TYPE_SUBEXPR) && (tokens.previous().subtype == TOK_SUBTYPE_STOP))\n                //    || (tokens.previous().type == TOK_TYPE_OPERAND)))\n                //  {}\n                doAddToken = doAddToken && (((tokens.next().type.toString() === TOK_TYPE_FUNCTION) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || ((tokens.next().type.toString() === TOK_TYPE_SUBEXPR) && (tokens.next().subtype.toString() === TOK_SUBTYPE_START)) || (tokens.next().type.toString() === TOK_TYPE_OPERAND));\n                //else if (!(\n                //\t((tokens.next().type == TOK_TYPE_FUNCTION) && (tokens.next().subtype == TOK_SUBTYPE_START))\n                //\t|| ((tokens.next().type == TOK_TYPE_SUBEXPR) && (tokens.next().subtype == TOK_SUBTYPE_START))\n                //\t|| (tokens.next().type == TOK_TYPE_OPERAND)))\n                //\t{}\n                //else { tokens2.add(token.value, TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT)};\n                if (doAddToken) {\n                    tokens2.add(token.value.toString(), TOK_TYPE_OP_IN, TOK_SUBTYPE_INTERSECT);\n                }\n                continue;\n            }\n\n            tokens2.addRef(token);\n\n        }\n\n        // switch infix \"-\" operator to prefix when appropriate, switch infix \"+\" operator to noop when appropriate, identify operand\n        // and infix-operator subtypes, pull \"@\" from in front of function names\n        while (tokens2.moveNext()) {\n\n            token = tokens2.current();\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"-\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_OP_PRE.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.value.toString() === \"+\")) {\n                if (tokens2.BOF()) {\n                    token.type = TOK_TYPE_NOOP.toString();\n                } else if (((tokens2.previous().type.toString() === TOK_TYPE_FUNCTION) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || ((tokens2.previous().type.toString() === TOK_TYPE_SUBEXPR) && (tokens2.previous().subtype.toString() === TOK_SUBTYPE_STOP)) || (tokens2.previous().type.toString() === TOK_TYPE_OP_POST) || (tokens2.previous().type.toString() === TOK_TYPE_OPERAND)) {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                } else {\n                    token.type = TOK_TYPE_NOOP.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OP_IN) && (token.subtype.length === 0)) {\n                if ((\"<>=\").indexOf(token.value.substr(0, 1)) !== -1) {\n                    token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                } else if (token.value.toString() === \"&\") {\n                    token.subtype = TOK_SUBTYPE_CONCAT.toString();\n                } else {\n                    token.subtype = TOK_SUBTYPE_MATH.toString();\n                }\n                continue;\n            }\n\n            if ((token.type.toString() === TOK_TYPE_OPERAND) && (token.subtype.length === 0)) {\n                if (isNaN(parseFloat(token.value))) {\n                    if ((token.value.toString() === 'TRUE') || (token.value.toString() === 'FALSE')) {\n                        token.subtype = TOK_SUBTYPE_LOGICAL.toString();\n                    } else {\n                        token.subtype = TOK_SUBTYPE_RANGE.toString();\n                    }\n                } else {\n                    token.subtype = TOK_SUBTYPE_NUMBER.toString();\n                }\n\n                continue;\n            }\n\n            if (token.type.toString() === TOK_TYPE_FUNCTION) {\n                if (token.value.substr(0, 1) === \"@\") {\n                    token.value = token.value.substr(1).toString();\n                }\n                continue;\n            }\n\n        }\n\n        tokens2.reset();\n\n        // move all tokens to a new collection, excluding all noops\n        tokens = new F_tokens();\n\n        while (tokens2.moveNext()) {\n            if (tokens2.current().type.toString() !== TOK_TYPE_NOOP) {\n                tokens.addRef(tokens2.current());\n            }\n        }\n\n        tokens.reset();\n\n        return tokens;\n    }\n\n\n    var parseFormula = excelFormulaUtilities.parseFormula = function (inputID, outputID) {\n\n\n        var indentCount = 0;\n\n        var indent = function () {\n            var s = \"|\",\n                i = 0;\n            for (; i < indentCount; i += 1) {\n                s += \"&nbsp;&nbsp;&nbsp;|\";\n            }\n            return s;\n        };\n\n        var formulaControl = document.getElementById(inputID);\n        var formula = formulaControl.value;\n\n        var tokens = getTokens(formula);\n\n        var tokensHtml = \"\";\n\n        tokensHtml += \"<table cellspacing='0' style='border-top: 1px #cecece solid; margin-top: 5px; margin-bottom: 5px'>\";\n        tokensHtml += \"<tr>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 50px'>index</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>type</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 125px'>subtype</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 150px'>token</td>\";\n        tokensHtml += \"<td class='token' style='font-weight: bold; width: 300px'>token tree</td></tr>\";\n\n        while (tokens.moveNext()) {\n\n            var token = tokens.current();\n\n            if (token.subtype === TOK_SUBTYPE_STOP) {\n                indentCount -= ((indentCount > 0) ? 1 : 0);\n            }\n\n            tokensHtml += \"<tr>\";\n\n            tokensHtml += \"<td class='token'>\" + (tokens.index + 1) + \"</td>\";\n\n            tokensHtml += \"<td class='token'>\" + token.type + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + ((token.subtype.length === 0) ? \"&nbsp;\" : token.subtype.toString()) + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n            tokensHtml += \"<td class='token'>\" + indent() + ((token.value.length === 0) ? \"&nbsp;\" : token.value).split(\" \").join(\"&nbsp;\") + \"</td>\";\n\n            tokensHtml += \"</tr>\";\n\n            if (token.subtype === TOK_SUBTYPE_START) {\n                indentCount += 1;\n            }\n\n        }\n\n        tokensHtml += \"</table>\";\n\n        document.getElementById(outputID).innerHTML = tokensHtml;\n\n        formulaControl.select();\n        formulaControl.focus();\n\n    };\n\n    // Pass a range such as A1:B2 along with a\n    // delimiter to get back a full list of ranges.\n    //\n    // Example:\n    //    breakOutRanges(\"A1:B2\", \"+\"); //Returns A1+A2+B1+B2\n    function breakOutRanges(rangeStr, delimStr){\n\n        //Quick Check to see if if rangeStr is a valid range\n        if ( !RegExp(\"[a-z]+[0-9]+:[a-z]+[0-9]+\",\"gi\").test(rangeStr) ){\n            throw \"This is not a valid range: \" + rangeStr;\n        }\n\n        //Make the rangeStr lowercase to deal with looping.\n        var range = rangeStr.split(\":\"),\n\n            startRow = parseInt(range[0].match(/[0-9]+/gi)[0]),\n            startCol = range[0].match(/[A-Z]+/gi)[0],\n            startColDec = fromBase26(startCol)\n\n            endRow =  parseInt(range[1].match(/[0-9]+/gi)[0]),\n            endCol = range[1].match(/[A-Z]+/gi)[0],\n            endColDec = fromBase26(endCol),\n\n            // Total rows and cols\n            totalRows = endRow - startRow + 1,\n            totalCols = fromBase26(endCol) - fromBase26(startCol) + 1,\n\n            // Loop vars\n            curCol = 0,\n            curRow = 1 ,\n            curCell = \"\",\n\n            //Return String\n            retStr = \"\";\n\n        for(; curRow <= totalRows; curRow+=1){\n            for(; curCol < totalCols; curCol+=1){\n                // Get the current cell id\n                curCell = toBase26(startColDec + curCol) + \"\" + (startRow+curRow-1) ;\n                retStr += curCell + (curRow===totalRows && curCol===totalCols-1 ? \"\" : delimStr);\n            }\n            curCol=0;\n        }\n\n        return retStr;\n\n    }\n\n    //Modified from function at http://en.wikipedia.org/wiki/Hexavigesimal\n    var toBase26 = excelFormulaUtilities.toBase26 = function( value ) {\n\n       value = Math.abs(value);\n\n       var converted = \"\"\n            ,iteration = false\n            ,remainder;\n\n       // Repeatedly divide the numerb by 26 and convert the\n       // remainder into the appropriate letter.\n       do {\n           remainder = value % 26;\n\n           // Compensate for the last letter of the series being corrected on 2 or more iterations.\n           if (iteration && value < 25) {\n               remainder--;\n           }\n\n           converted = String.fromCharCode((remainder + 'A'.charCodeAt(0))) + converted;\n           value = Math.floor((value - remainder) / 26);\n\n           iteration = true;\n       } while (value > 0);\n\n       return converted;\n   }\n\n   // This was Modified from a function at http://en.wikipedia.org/wiki/Hexavigesimal\n   // Pass in the base 26 string, get back integer\n   var fromBase26 = excelFormulaUtilities.fromBase26 = function (number) {\n        number = number.toUpperCase();\n\n        var s = 0\n            ,i = 0\n            ,dec = 0;\n\n        if (\n            number !== null\n            && typeof number !== \"undefined\"\n            && number.length > 0\n        ) {\n            for (; i < number.length; i++) {\n                s = number.charCodeAt(number.length - i - 1) - \"A\".charCodeAt(0);\n                dec += (Math.pow(26, i)) * (s+1);\n            }\n        }\n\n        return dec - 1;\n    }\n\n    function applyTokenTemplate(token, options, indent, lineBreak, override) {\n\n        var indt = indent;\n\n        var lastToken = typeof arguments[5] === undefined || arguments[5] === null ? null : arguments[5];\n\n        var replaceTokenTmpl = function (inStr) {\n            return inStr.replace(/\\{\\{token\\}\\}/gi, \"{0}\").replace(/\\{\\{autoindent\\}\\}/gi, \"{1}\").replace(/\\{\\{autolinebreak\\}\\}/gi, \"{2}\");\n        };\n\n        var tokenString = \"\";\n\n        if (token.subtype === \"text\" || token.type === \"text\") {\n            tokenString = token.value.toString();\n        } else if ( token.type === 'operand' && token.subtype === 'range') {\n            tokenString = token.value.toString() ;\n        } else {\n            tokenString = ((token.value.length === 0) ? \" \" : token.value.toString()).split(\" \").join(\"\").toString();\n        }\n\n        if (typeof override === 'function') {\n            var returnVal = override(tokenString, token, indent, lineBreak);\n\n            tokenString = returnVal.tokenString;\n\n            if (!returnVal.useTemplate) {\n                return tokenString;\n            }\n        }\n\n        switch (token.type) {\n\n        case \"function\":\n            //-----------------FUNCTION------------------\n            switch (token.value) {\n            case \"ARRAY\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArray), tokenString, indt, lineBreak);\n                break;\n            case \"ARRAYROW\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStartArrayRow), tokenString, indt, lineBreak);\n                break;\n            default:\n                if (token.subtype.toString() === \"start\") {\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStart), tokenString, indt, lineBreak);\n                } else {\n                    tokenString = formatStr(replaceTokenTmpl(options.tmplFunctionStop), tokenString, indt, lineBreak);\n                }\n                break;\n            }\n            break;\n        case \"operand\":\n            //-----------------OPERAND------------------\n            switch (token.subtype.toString()) {\n            case \"error\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandError), tokenString, indt, lineBreak);\n                break;\n            case \"range\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandRange), tokenString, indt, lineBreak);\n                break;\n            case \"logical\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandLogical), tokenString, indt, lineBreak);\n            break;\n            case \"number\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandNumber), tokenString, indt, lineBreak);\n                break;\n            case \"text\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplOperandText), tokenString, indt, lineBreak);\n                break;\n            case \"argument\":\n                tokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n                break;\n            default:\n                break;\n            }\n            break;\n        case \"operator-infix\":\n            tokenString = formatStr(replaceTokenTmpl(options.tmplOperandOperatorInfix), tokenString, indt, lineBreak);\n            break;\n        case \"logical\":\n            tokenString = formatStr(replaceTokenTmpl(options.tmplLogical), tokenString, indt, lineBreak);\n            break;\n        case \"argument\":\n        \tif(lastToken.type !== \"argument\"){\n        \t\ttokenString = formatStr(replaceTokenTmpl(options.tmplArgument), tokenString, indt, lineBreak);\n            } else  {\n            \ttokenString = formatStr(replaceTokenTmpl(\"{{autoindent}}\"+options.tmplArgument), tokenString, indt, lineBreak);\n            }\n            break;\n        case \"subexpression\":\n            if (token.subtype.toString() === \"start\") {\n                tokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStart), tokenString, indt, lineBreak);\n            } else {\n                tokenString = formatStr(replaceTokenTmpl(options.tmplSubexpressionStop), tokenString, indt, lineBreak);\n            }\n            break;\n        default:\n\n            break;\n        }\n        return tokenString;\n    };\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n     *<pre>\n     *   TEMPLATE VALUES\n     *  {{autoindent}} - apply auto indent based on current tree level\n     *  {{token}} - the named token such as FUNCTION_NAME or \"string\"\n     *  {{autolinebreak}} - apply linbreak automaticly. tests for next element only at this point\n     *\n     * Options include:\n     *  tmplFunctionStart           - template for the start of a function, the {{token}} will contain the name of the function.\n     *  tmplFunctionStop            - template for when the end of a function has been reached.\n     *  tmplOperandError            - template for errors.\n     *  tmplOperandRange            - template for ranges and variable names.\n     *  tmplOperandLogical          - template for logical operators such as + - = ...\n     *  tmplOperandNumber           - template for numbers.\n     *  tmplOperandText             - template for text/strings.\n     *  tmplArgument\t\t\t\t- template for argument seperators such as ,.\n     *  tmplFunctionStartArray      - template for the start of an array.\n     *  tmplFunctionStartArrayRow   - template for the start of an array row.\n     *  tmplFunctionStopArrayRow    - template for the end of an array row.\n     *  tmplFunctionStopArray       - template for the end of an array.\n     *  tmplSubexpressionStart      - template for the sub expresson start\n     *  tmplSubexpressionStop       - template for the sub expresson stop\n     *  tmplIndentTab               - template for the tab char.\n     *  tmplIndentSpace             - template for space char.\n     *  autoLineBreak               - when rendering line breaks automaticly which types should it break on. \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\"\n     *  newLine                     - used for the {{autolinebreak}} replacement as well as some string parsing. if this is not set correctly you may get undesired results. usually \\n for text or <br /> for html\n     *  trim: true                  - trim the output.\n     *\tcustomTokenRender: null     - this is a call back to a custom token function. your call back should look like\n     *                                EXAMPLE:\n     *\n     *                                    customTokenRender: function(tokenString, token, indent, linbreak){\n     *                                        var outstr = token,\n     *                                            useTemplate = true;\n     *                                        // In the return object \"useTemplate\" tells formatFormula()\n     *                                        // weather or not to apply the template to what your return from the \"tokenString\".\n     *                                        return {tokenString: outstr, useTemplate: useTemplate};\n     *                                    }\n     *\n     *</pre>\n     * @returns {string}\n     */\n    var formatFormula = excelFormulaUtilities.formatFormula = function (formula, options) {\n        //Quick fix for trailing space after = sign\n        formula = formula.replace(/^\\s*=\\s+/, \"=\");\n\n        var isFirstToken = true,\n            defaultOptions = {\n                tmplFunctionStart: '{{autoindent}}{{token}}(\\n',\n                tmplFunctionStop: '\\n{{autoindent}}{{token}})',\n                tmplOperandError: ' {{token}}',\n                tmplOperandRange: '{{autoindent}}{{token}}',\n                tmplLogical: '{{token}}{{autolinebreak}}',\n                tmplOperandLogical: '{{autoindent}}{{token}}',\n                tmplOperandNumber: '{{autoindent}}{{token}}',\n                tmplOperandText: '{{autoindent}}\"{{token}}\"',\n                tmplArgument: '{{token}}\\n',\n                tmplOperandOperatorInfix: ' {{token}}{{autolinebreak}}',\n                tmplFunctionStartArray: '',\n                tmplFunctionStartArrayRow: '{',\n                tmplFunctionStopArrayRow: '}',\n                tmplFunctionStopArray: '',\n                tmplSubexpressionStart: '{{autoindent}}(\\n',\n                tmplSubexpressionStop: '\\n)',\n                tmplIndentTab: '\\t',\n                tmplIndentSpace: ' ',\n                autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n                newLine: '\\n',\n                //trim: true,\n                customTokenRender: null,\n                prefix: \"\",\n                postfix: \"\"\n            };\n\n        if (options) {\n            options = core.extend(true, defaultOptions, options);\n        } else {\n            options = defaultOptions;\n        }\n\n        var indentCount = 0;\n\n        var indent = function () {\n            var s = \"\",\n                i = 0;\n\n            for (; i < indentCount; i += 1) {\n                s += options.tmplIndentTab;\n            }\n            return s;\n        };\n\n        var tokens = getTokens(formula);\n\n        var outputFormula = \"\";\n\n        var autoBreakArray = options.autoLineBreak.replace(/\\s/gi, \"\").split(\"|\");\n\n        //Tokens\n        var isNewLine = true;\n\n        var testAutoBreak = function (nextToken) {\n            var i = 0;\n            for (; i < autoBreakArray.length; i += 1) {\n                if (nextToken !== null && typeof nextToken !== 'undefined' && (types[autoBreakArray[i]] === nextToken.type.toString() || types[autoBreakArray[i]] === nextToken.subtype.toString())) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        var lastToken = null;\n\n        while (tokens.moveNext()) {\n\n            var token = tokens.current();\n            var nextToken = tokens.next();\n\n            if (token.subtype.toString() === TOK_SUBTYPE_STOP) {\n                indentCount -= ((indentCount > 0) ? 1 : 0);\n            }\n\n            var matchBeginNewline = new RegExp('^' + options.newLine, ''),\n                matchEndNewLine = new RegExp(options.newLine + '$', ''),\n                autoBreak = testAutoBreak(nextToken),\n                autoIndent = isNewLine,\n                indt = autoIndent ? indent() : options.tmplIndentSpace,\n                lineBreak = autoBreak ? options.newLine : \"\";\n\n            // TODO this strips out spaces which breaks part of issue 28.  'Data Sheet' gets changed to DataSheet\n            outputFormula += applyTokenTemplate(token, options, indt, lineBreak, options.customTokenRender, lastToken);\n\n            if (token.subtype.toString() === TOK_SUBTYPE_START) {\n                indentCount += 1;\n\n            }\n\n            isNewLine = autoBreak || matchEndNewLine.test(outputFormula);\n            isFirstToken = false;\n\n            lastToken = token;\n        }\n\n        outputFormula = options.prefix + trim(outputFormula) + options.postfix;\n\n        return outputFormula;\n    };\n    /**\n     * This function calls {@link excelFormulaUtilities.parser.formatFormula}\n     *\n     * @memberof excelFormulaUtilities.parser\n     * @function\n     * @param {string} formula\n     * @param {object} options optional param\n     */\n    var formatFormulaHTML = excelFormulaUtilities.formatFormulaHTML = function (formula, options) {\n        var tokRender = function(tokenStr, token, indent, linbreak){\n          var outstr = tokenStr;\n          switch (token.type.toString()) {\n            case TOK_TYPE_OPERAND:\n              if(token.subtype === TOK_SUBTYPE_TEXT){\n                outstr = tokenStr.replace(/</gi,\"&lt;\").replace(/>/gi,\"&gt;\");\n              }\n              break;\n          }\n\n          return {\n              tokenString: outstr,\n              useTemplate: true\n          };\n        }\n        var defaultOptions = {\n            tmplFunctionStart: '{{autoindent}}<span class=\"function\">{{token}}</span><span class=\"function_start\">(</span><br />',\n            tmplFunctionStop: '<br />{{autoindent}}{{token}}<span class=\"function_stop\">)</span>',\n            tmplOperandText: '{{autoindent}}<span class=\"quote_mark\">\"</span><span class=\"text\">{{token}}</span><span class=\"quote_mark\">\"</span>',\n            tmplArgument: '{{token}}<br />',\n            tmplSubexpressionStart: '{{autoindent}}(',\n            tmplSubexpressionStop: ' )',\n            tmplIndentTab: '<span class=\"tabbed\">&nbsp;&nbsp;&nbsp;&nbsp;</span>',\n            tmplIndentSpace: '&nbsp;',\n            newLine: '<br />',\n            autoLineBreak: 'TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ',\n            trim: true,\n            prefix: \"=\",\n            customTokenRender: tokRender\n        };\n\n        if (options) {\n            options = core.extend(true, defaultOptions, options);\n        } else {\n            options = defaultOptions;\n        }\n\n        return formatFormula(formula, options);\n    }\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2CSharp = excelFormulaUtilities.formula2CSharp = function (formula, options) {\n\n        //Custom callback to format as c#\n        var functionStack = [];\n\n        var tokRender = function (tokenStr, token, indent, linbreak) {\n            var outstr = \"\",\n                /*tokenString = (token.value.length === 0) ? \"\" : token.value.toString(),*/\n                tokenString = tokenStr,\n                directConversionMap = {\n                    \"=\": \"==\",\n                    \"<>\": \"!=\",\n                    \"MIN\": \"Math.min\",\n                    \"MAX\": \"Math.max\",\n                    \"ABS\": \"Math.abs\",\n                    \"SUM\": \"\",\n                    \"IF\": \"\",\n                    \"&\": \"+\",\n                    \"AND\": \"\",\n                    \"OR\": \"\"\n                },\n                currentFunctionOnStack = functionStack[functionStack.length - 1],\n                useTemplate = false;\n\n            switch (token.type.toString()) {\n\n            case TOK_TYPE_FUNCTION:\n\n                switch (token.subtype) {\n\n                case TOK_SUBTYPE_START:\n\n                    functionStack.push({\n                        name: tokenString,\n                        argumentNumber: 0\n                    });\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n\n                    break;\n\n                case TOK_SUBTYPE_STOP:\n\n                    useTemplate = true;\n                    switch (currentFunctionOnStack.name.toLowerCase()) {\n                    case \"if\":\n                        outstr = currentFunctionOnStack.argumentNumber === 1 ? \":0)\" : \")\";\n                        useTemplate = false;\n                        break;\n                    default:\n                        outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                        break\n                    }\n                    functionStack.pop();\n                    break;\n                }\n\n                break;\n\n            case TOK_TYPE_ARGUMENT:\n                switch (currentFunctionOnStack.name.toLowerCase()) {\n                case \"if\":\n                    switch (currentFunctionOnStack.argumentNumber) {\n                    case 0:\n                        outstr = \"?\";\n                        break;\n                    case 1:\n                        outstr = \":\";\n                        break;\n                    }\n                    break;\n                case \"sum\":\n                    outstr = \"+\";\n                    break;\n                case \"and\":\n                    outstr = \"&&\";\n                    break;\n                case \"or\":\n                    outstr = \"||\";\n                    break;\n                default:\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n                    break;\n                }\n\n                currentFunctionOnStack.argumentNumber += 1;\n\n                break;\n\n            case TOK_TYPE_OPERAND:\n\n                switch (token.subtype) {\n\n                    case TOK_SUBTYPE_RANGE:\n                        //Assume '=' sign\n                        if(!currentFunctionOnStack){\n                          break;\n                        }\n                        switch (currentFunctionOnStack.name.toLowerCase()) {\n                        // If in the sum function break aout cell names and add\n                        case \"sum\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \"+\");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        case \"and\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \"&&\");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        case \"or\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \"||\");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        // By Default return an array containing all cell names in array\n                        default:\n                            // Create array for ranges\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = \"[\" + breakOutRanges(tokenString, \",\") +\"]\";\n                            } else {\n                                outstr = tokenString;\n                            }\n                            //debugger;\n                            break;\n                        }\n\n                        break;\n\n                    default:\n                        break;\n                }\n\n            default:\n                if( outstr === \"\" ){\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                }\n                useTemplate = true;\n                break;\n            }\n\n            return {\n                tokenString: outstr,\n                useTemplate: useTemplate\n            };\n        };\n\n        var defaultOptions = {\n            tmplFunctionStart: '{{token}}(',\n            tmplFunctionStop: '{{token}})',\n            tmplOperandError: '{{token}}',\n            tmplOperandRange: '{{token}}',\n            tmplOperandLogical: '{{token}}',\n            tmplOperandNumber: '{{token}}',\n            tmplOperandText: '\"{{token}}\"',\n            tmplArgument: '{{token}}',\n            tmplOperandOperatorInfix: '{{token}}',\n            tmplFunctionStartArray: \"\",\n            tmplFunctionStartArrayRow: \"{\",\n            tmplFunctionStopArrayRow: \"}\",\n            tmplFunctionStopArray: \"\",\n            tmplSubexpressionStart: \"(\",\n            tmplSubexpressionStop: \")\",\n            tmplIndentTab: \"\\t\",\n            tmplIndentSpace: \" \",\n            autoLineBreak: \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\",\n            trim: true,\n            customTokenRender: tokRender\n        };\n\n        if (options) {\n            options = core.extend(true, defaultOptions, options);\n        } else {\n            options = defaultOptions;\n        }\n\n        var cSharpOutput = formatFormula(formula, options);\n        return cSharpOutput;\n    };\n\n    /**\n     * Both the csharp and javascript are the same when converted, this is just an alias for convert2CSharp. there are some subtle differences such as == vrs ===, this will be addressed in a later version.\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2JavaScript = excelFormulaUtilities.formula2JavaScript = function (formula, options) {\n        return formula2CSharp(formula, options).replace('==', '===');\n    }\n\n    /**\n     *\n     * @memberof excelFormulaUtilities.convert\n     * @function\n     * @param {string} formula\n     * @returns {string}\n     */\n    var formula2Python = excelFormulaUtilities.formula2Python = function (formula, options) {\n\n        //Custom callback to format as c#\n        var functionStack = [];\n\n        var tokRender = function (tokenStr, token, indent, linbreak) {\n            var outstr = \"\",\n                /*tokenString = (token.value.length === 0) ? \"\" : token.value.toString(),*/\n                tokenString = tokenStr,\n                directConversionMap = {\n                    \"=\": \"==\",\n                    \"<>\": \"!=\",\n                    \"MIN\": \"min\",\n                    \"MAX\": \"max\",\n                    \"ABS\": \"math.fabs\",\n                    \"SUM\": \"\",\n                    \"IF\": \"\",\n                    \"&\": \"+\",\n                    \"AND\": \"\",\n                    \"OR\": \"\",\n                    \"NOT\": \"!\",\n                    \"TRUE\": \"True\",\n                    \"FALSE\": \"False\"\n                },\n                currentFunctionOnStack = functionStack[functionStack.length - 1],\n                useTemplate = false;\n\n            switch (token.type.toString()) {\n\n            case TOK_TYPE_FUNCTION:\n\n                switch (token.subtype) {\n\n                case TOK_SUBTYPE_START:\n\n                    functionStack.push({\n                        name: tokenString,\n                        argumentNumber: 0\n                    });\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n\n                    break;\n\n                case TOK_SUBTYPE_STOP:\n\n                    useTemplate = true;\n                    switch (currentFunctionOnStack.name.toLowerCase()) {\n                    case \"if\":\n                        outstr = \",))[0]\";\n                        if (currentFunctionOnStack.argumentNumber === 1) {\n                          outstr = \" or (0\" + outstr;\n                        }\n                        useTemplate = false;\n                        break;\n                    default:\n                        outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                        break\n                    }\n                    functionStack.pop();\n                    break;\n                }\n\n                break;\n\n            case TOK_TYPE_ARGUMENT:\n                switch (currentFunctionOnStack.name.toLowerCase()) {\n                case \"if\":\n                    switch (currentFunctionOnStack.argumentNumber) {\n                    case 0:\n                        outstr = \" and (\";\n                        break;\n                    case 1:\n                        outstr = \",) or (\";\n                        break;\n                    }\n                    break;\n                case \"sum\":\n                    outstr = \"+\";\n                    break;\n                case \"and\":\n                    outstr = \" and \";\n                    break;\n                case \"or\":\n                    outstr = \" or \";\n                    break;\n                default:\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                    useTemplate = true;\n                    break;\n                }\n\n                currentFunctionOnStack.argumentNumber += 1;\n\n                break;\n\n            case TOK_TYPE_OPERAND:\n\n                switch (token.subtype) {\n\n                    case TOK_SUBTYPE_RANGE:\n                        //Assume '=' sign\n                        if(!currentFunctionOnStack){\n                          break;\n                        }\n\n                        if (RegExp(\"true|false\", \"gi\").test(tokenString)) {\n                          outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                          break;\n                        }\n\n                        switch (currentFunctionOnStack.name.toLowerCase()) {\n                        // If in the sum function break aout cell names and add\n                        case \"sum\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \"+\");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        case \"and\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \" and \");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        case \"or\":\n                            //TODO make sure this is working\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = breakOutRanges(tokenString, \" or \");\n                            } else {\n                                outStr = tokenString;\n                            }\n\n                            break;\n                        // By Default return an array containing all cell names in array\n                        default:\n                            // Create array for ranges\n                            if(RegExp(\":\",\"gi\").test(tokenString)){\n                                outstr = \"[\" + breakOutRanges(tokenString, \",\") +\"]\";\n                            } else {\n                                outstr = tokenString;\n                            }\n                            //debugger;\n                            break;\n                        }\n\n                        break;\n\n                    default:\n                        break;\n                }\n\n            default:\n                if( outstr === \"\" ){\n                    outstr = typeof directConversionMap[tokenString.toUpperCase()] === \"string\" ? directConversionMap[tokenString.toUpperCase()] : tokenString;\n                }\n                useTemplate = true;\n                break;\n            }\n\n            return {\n                tokenString: outstr,\n                useTemplate: useTemplate\n            };\n        };\n\n        var defaultOptions = {\n            tmplFunctionStart: '{{token}}(',\n            tmplFunctionStop: '{{token}})',\n            tmplOperandError: '{{token}}',\n            tmplOperandRange: '{{token}}',\n            tmplOperandLogical: '{{token}}',\n            tmplOperandNumber: '{{token}}',\n            tmplOperandText: '\"{{token}}\"',\n            tmplArgument: '{{token}}',\n            tmplOperandOperatorInfix: '{{token}}',\n            tmplFunctionStartArray: \"\",\n            tmplFunctionStartArrayRow: \"{\",\n            tmplFunctionStopArrayRow: \"}\",\n            tmplFunctionStopArray: \"\",\n            tmplSubexpressionStart: \"(\",\n            tmplSubexpressionStop: \")\",\n            tmplIndentTab: \"\\t\",\n            tmplIndentSpace: \" \",\n            autoLineBreak: \"TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT\",\n            trim: true,\n            customTokenRender: tokRender\n        };\n\n        if (options) {\n            options = core.extend(true, defaultOptions, options);\n        } else {\n            options = defaultOptions;\n        }\n\n        var pythonOutput = formatFormula(formula, options);\n\n        return pythonOutput;\n    };\n\n    excelFormulaUtilities.getTokens = getTokens;\n\n}(window|| module.exports || {}));\n"],"sourceRoot":""}